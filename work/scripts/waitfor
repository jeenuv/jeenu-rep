#!/bin/bash

# Script to wait until a PID or an input pattern disappears from the list
# of processes. I.e. they are termiated. This would come in handy to queue another
# process, say, another download, only after the current one is finished.
#
# The command to get the list of processes is first obtained from $PS_COMMAND, if set.
# This is particularly useful in Cygwin, where -W, a non standard option, is needed to
# view Windows processes
#
# If there's a second argument, that's assumed as a command to be executed after woke
# up from sleep

pat=
ps_command="${PS_COMMAND:-ps aux}"
usage="Usage: waitfor [-w <until>] [-t <wait>] [-c <command>] identifier"
wait_until=0
wait_time=5
wait_command=

if [ -z "$*" ]; then
    echo "$usage"
    exit 1
fi

if ! which getopt >/dev/null; then
    echo "waitfor: This script requires GNU getopt in \$PATH"
    exit 1
fi

eval set -- $(getopt -o "w:t:c:" -q -- "$@")

if [ "$?" -ne 0 -a "$?" -ne 1 ]; then
    echo "waitfor: 'getopt' returned error"
    exit 1
fi

until [ -z "$*" ]; do
    case "$1" in
        -w)
        shift
        wait_until="$1"
        ;;

        -t)
        shift
        wait_time="$1"
        ;;

        -c)
        shift
        wait_command="$1"
        ;;

        --)
        shift
        break
        ;;
    esac

    shift
done

if [ -z "$1" ]; then
    echo "$usage"
    exit 1
fi

sleep "$wait_until"
# Convert, say, wget to [w]get
pat="$(echo "$1" | sed 's/./[&]/')"
while $ps_command | grep -v waitfor | grep -q "$pat"; do
    $wait_command
    sleep "$wait_time"
done
